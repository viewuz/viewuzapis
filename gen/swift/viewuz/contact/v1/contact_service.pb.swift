// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: viewuz/contact/v1/contact_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Viewuz_Contact_V1_CreateContactRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user to create the contact
  var parent: String = String()

  /// The contact to create
  var contact: Viewuz_Contact_V1_Contact {
    get {return _contact ?? Viewuz_Contact_V1_Contact()}
    set {_contact = newValue}
  }
  /// Returns true if `contact` has been explicitly set.
  var hasContact: Bool {return self._contact != nil}
  /// Clears the value of `contact`. Subsequent reads from it will return its default value.
  mutating func clearContact() {self._contact = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _contact: Viewuz_Contact_V1_Contact? = nil
}

struct Viewuz_Contact_V1_BatchCreateContactsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The parent resource shared by all books being created.
  /// If this is set, the parent field in the CreateBookRequest messages
  /// must either be empty or match this field.
  var parent: String = String()

  /// The request message specifying the resources to create.
  /// A maximum of 1000 contacts can be created in a batch.
  var requests: [Viewuz_Contact_V1_CreateContactRequest] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Viewuz_Contact_V1_BatchCreateContactsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Contacts created.
  var contacts: [Viewuz_Contact_V1_Contact] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Viewuz_Contact_V1_ListContactsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The parent, which owns this collection of contacts.
  var parent: String = String()

  /// The maximum number of contacts to return. The service may return fewer than this value.
  /// If unspecified, at most 50 will be returned.
  /// The maximum value is 1000; values above 1000 will be coerced to 1000.
  var pageSize: Int32 = 0

  /// A page token, received from a previous `ListBooks` call.
  /// Provide this to retrieve the subsequent page.
  /// When paginating, all other parameters provided to `ListContacts` must match
  /// the call that provided the page token.
  var pageToken: String = String()

  /// The order to list results by.
  /// Values should be a comma separated list of fields
  /// The default sorting order is ascending. To specify descending order for a field, users append a " desc" suffix;
  /// Subfields are specified with a . character
  /// Redundant space characters in the syntax are insignificant.
  /// Example: `display_name desc, created_at asc`
  var orderBy: String = String()

  /// The filter to apply to list results.
  /// Reference: [https://google.aip.dev/160]
  var filter: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Viewuz_Contact_V1_ListContactsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The contacts from the specified user.
  var contacts: [Viewuz_Contact_V1_Contact] = []

  /// A token, which can be sent as `page_token` to retrieve the next page.
  /// If this field is omitted, there are no subsequent pages.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "viewuz.contact.v1"

extension Viewuz_Contact_V1_CreateContactRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateContactRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "contact"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._contact) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    try { if let v = self._contact {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Viewuz_Contact_V1_CreateContactRequest, rhs: Viewuz_Contact_V1_CreateContactRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._contact != rhs._contact {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Viewuz_Contact_V1_BatchCreateContactsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchCreateContactsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "requests"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.requests) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.requests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requests, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Viewuz_Contact_V1_BatchCreateContactsRequest, rhs: Viewuz_Contact_V1_BatchCreateContactsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.requests != rhs.requests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Viewuz_Contact_V1_BatchCreateContactsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchCreateContactsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contacts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.contacts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contacts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.contacts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Viewuz_Contact_V1_BatchCreateContactsResponse, rhs: Viewuz_Contact_V1_BatchCreateContactsResponse) -> Bool {
    if lhs.contacts != rhs.contacts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Viewuz_Contact_V1_ListContactsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListContactsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    4: .standard(proto: "order_by"),
    5: .same(proto: "filter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.orderBy) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    if !self.orderBy.isEmpty {
      try visitor.visitSingularStringField(value: self.orderBy, fieldNumber: 4)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Viewuz_Contact_V1_ListContactsRequest, rhs: Viewuz_Contact_V1_ListContactsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Viewuz_Contact_V1_ListContactsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListContactsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contacts"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.contacts) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contacts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.contacts, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Viewuz_Contact_V1_ListContactsResponse, rhs: Viewuz_Contact_V1_ListContactsResponse) -> Bool {
    if lhs.contacts != rhs.contacts {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
